// packages/plugin-email/src/utils/emailListener.ts
import type { IAgentRuntime, Memory } from "@elizaos/core";
import { elizaLogger, stringToUuid, validateUuid } from "@elizaos/core";
import { EmailClient } from "../clients/emailClient";
import { emailProvider } from "../providers/emailProvider";
import { type ExtendedEmailContent } from "../types";
import { simpleParser } from 'mailparser';
import { fetchRecentEmails, storeEmailToBigQuery, generateEmailEmbedding } from "./bigQuery";

const REGULAR_NOTIFICATION_INTERVAL = 60000; // 60 seconds

interface EmailMetadata {
  from?: { address?: string; name?: string }[];
  subject?: string;
  date?: string | Date;
  emailId?: string;
  messageId?: string;
  references?: string[];
  threadId?: string;
  collection: string;
  originalEmailId?: string;
  originalMessageId?: string;
  originalThreadId?: string;
  body?: string;
}

interface EmailMemory extends Omit<Memory, "content"> {
  content: {
    text: string;
    metadata?: EmailMetadata;
    action?: string;
    source?: string;
    url?: string;
    inReplyTo?: `${string}-${string}-${string}-${string}-${string}` | undefined;
    attachments?: any[];
    [key: string]: unknown;
  };
}

function normalizeId(id: string | undefined): `${string}-${string}-${string}-${string}-${string}` | undefined {
  if (!id) return undefined;
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  if (uuidRegex.test(id)) return id as `${string}-${string}-${string}-${string}-${string}`;
  return stringToUuid(id) as `${string}-${string}-${string}-${string}-${string}`;
}

export function setupEmailListener(runtime: IAgentRuntime, emailClient: EmailClient) {
  elizaLogger.debug(`[EmailListener:${runtime.character.id}] Setting up email listener`, { roomId: runtime.character.id });

  const intervals: NodeJS.Timeout[] = [];

  emailClient.receive(async (mail: ExtendedEmailContent) => {
    elizaLogger.info(`[EmailListener:${runtime.character.id}] Received email`, {
      messageId: mail.messageId,
      from: mail.from,
      subject: mail.subject,
      roomId: runtime.character.id,
    });

    // Parse email to extract clean body
    let parsedBody = mail.text || mail.subject || "No content";
    try {
      const parsed = await simpleParser(mail.text || '');
      parsedBody = parsed.text || parsed.textAsHtml || mail.subject || "No content";
      parsedBody = parsedBody
        .split(/^-{2,}\s*Original Message\s*-{2,}|^-{2,}\s*Forwarded Message\s*-{2,}/gim)[0]
        .trim();
      elizaLogger.info(`[EmailListener:${runtime.character.id}] Parsed email body`, {
        parsedBody,
        emailUUID: mail.emailUUID,
      });
    } catch (error: any) {
      elizaLogger.warn(`[EmailListener:${runtime.character.id}] Failed to parse email`, {
        error: error.message,
        emailUUID: mail.emailUUID,
      });
    }

    const emailUUID = mail.emailUUID || stringToUuid(mail.messageId || `${Date.now()}${Math.random()}`);
    if (!validateUuid(emailUUID)) {
      elizaLogger.error(`[EmailListener:${runtime.character.id}] Generated invalid email UUID`, {
        emailUUID,
        originalEmailId: mail.messageId,
      });
      throw new Error(`Invalid email UUID generated for messageId: ${mail.messageId}`);
    }

    // Store email to BigQuery and GCS with parsed body
    try {
      await storeEmailToBigQuery({ ...mail, text: parsedBody }, runtime.character.id); // Pass parsedBody as mail.text
      elizaLogger.info(`[EmailListener:${runtime.character.id}] Stored email to BigQuery`, {
        emailUUID,
        subject: mail.subject,
        roomId: runtime.character.id,
      });

      // Generate embedding
      try {
        await generateEmailEmbedding(emailUUID);
        elizaLogger.info(`[EmailListener:${runtime.character.id}] Generated embedding for email`, { emailUUID });
      } catch (error: any) {
        elizaLogger.error(`[EmailListener:${runtime.character.id}] Failed to generate embedding`, {
          error: error.message,
          emailUUID,
        });
      }
    } catch (error: any) {
      elizaLogger.error(`[EmailListener:${runtime.character.id}] Failed to store email`, {
        error: error.message,
        emailUUID: mail.emailUUID,
      });
      return;
    }

    // Check for importance
    const isImportant =
      mail.from?.some((f) => f.address?.toLowerCase().includes("important@domain.com")) ||
      mail.subject?.toLowerCase().includes("urgent") ||
      mail.text?.toLowerCase().includes("urgent");

    if (isImportant) {
      const syntheticMessage: Memory = {
        id: stringToUuid(`${Date.now()}${Math.random()}`),
        content: { text: "New important email received" },
        agentId: runtime.agentId,
        roomId: runtime.character.id,
        userId: runtime.character.id,
        createdAt: Date.now(),
      };
      elizaLogger.debug(`[EmailListener:${runtime.character.id}] Triggering important email notification`, {
        emailUUID,
        originalEmailId: mail.messageId,
        subject: mail.subject,
        roomId: runtime.character.id,
      });
      await emailProvider.get(runtime, syntheticMessage);
    }
  });

  // Periodic notification for new emails
  intervals.push(
    setInterval(async () => {
      const recentEmails = await fetchRecentEmails(runtime.character.id, 10);
      if (recentEmails.length === 0) return;
      const syntheticMessage: Memory = {
        id: stringToUuid(`${Date.now()}${Math.random()}`),
        content: { text: `You have ${recentEmails.length} new email${recentEmails.length > 1 ? 's' : ''}` },
        agentId: runtime.agentId,
        roomId: runtime.character.id,
        userId: runtime.character.id,
        createdAt: Date.now(),
      };
      elizaLogger.debug(`[EmailListener:${runtime.character.id}] Triggering regular email notification`, {
        count: recentEmails.length,
        roomId: runtime.character.id,
      });
      await emailProvider.get(runtime, syntheticMessage);
    }, REGULAR_NOTIFICATION_INTERVAL)
  );

  process.on("SIGTERM", async () => {
    intervals.forEach(clearInterval);
    await emailClient.stop();
  });

  elizaLogger.debug(`[EmailListener:${runtime.character.id}] Email listener setup complete`, {
    roomId: runtime.character.id,
  });
}